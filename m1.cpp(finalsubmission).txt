/* 
 * Copyright 2021 University of Toronto
 *
 * Permission is hereby granted, to use this software and associated 
 * documentation files (the "Software") in course work at the University 
 * of Toronto, or for personal use. Other uses are prohibited, in 
 * particular the distribution of the Software either publicly or to third 
 * parties.
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <iostream>
#include <math.h>
#include <string>
#include <algorithm>
#include <vector>
#include <unordered_set>
#include <map>
#include <cctype>
#include <locale>
#include <unordered_map>
#include "point.hpp"
#include "m1.h"
#include "StreetsDatabaseAPI.h"
#include "OSMDatabaseAPI.h"
#include "globals.h"
#include "m2.h"
#include <math.h>
#include "m3.h"
#include "m3.cpp"


double lat_from_y(float y); 
double x_from_lon(float lon);
double lon_from_x(float x);
double y_from_lat(double lat);


std::vector<bool> isSegPartOfPath;

double findClosestPOI_to_POIDistance(POIIdx thisPOI_ID);

bool isHighway = false;
std::string map_path;

struct Intersections {
    LatLon position;
    std::vector<IntersectionIdx> l;
};

std::vector<FeatureData> features;

std::unordered_map<OSMID, const OSMWay*> umap;
std::unordered_map<IntersectionIdx, Node> searchmap;
std::unordered_map<IntersectionIdx, std::vector<StreetSegmentIdx>> findss;
std::vector<std::unordered_map<StreetSegmentIdx, IntersectionIdx>> ajacent_segments;
std::vector<StreetSegmentIdx> adjacentS;
std::vector<std::vector<IntersectionIdx>> intersectionAdj;

std::vector<Node> searchNode ;  
std::vector<std::vector<StreetSegmentIdx>> findAdjs ;


std::vector<std::vector<StreetSegmentIdx>> intersection_streetSegments; //stores the street segments joined to each intersection
std::vector<std::vector<StreetSegmentIdx>> street_streetSegments; //stores the street segments contained in each street
std::vector<std::vector<IntersectionIdx>> streetSegments_intersection; //stores the intersections that each street segment is connected to
std::vector<std::vector<IntersectionIdx>> street_intersectionId; //stores the intersections that lie on each street
std::vector<std::pair<std::string, StreetIdx>> streetNameAndID;
std::vector<double> streetSegmentsLength;
std::vector<double> streetSegmentsTravelTime;
std::vector<double> streetLengths;


// loadMap will be called with the name of the file that stores the "layer-2"
// map data accessed through StreetsDatabaseAPI: the street and intersections
// data that is higher-level than the raw OSM data). 
// This file name will always end in ".streets.bin" and you 
// can call loadStreetsDatabaseBIN with this filename to initialize the
// layer 2 (StreetsDatabase) API.
// If you need data from the lower level, layer 1, API that provides raw OSM
// data (nodes, ways, etc.) you will also need to initialize the layer 1 
// OSMDatabaseAPI by calling loadOSMDatabaseBIN. That function needs the 
// name of the ".osm.bin" file that matches your map -- just change 
// ".streets" to ".osm" in the map_streets_database_filename to get the proper
// name.


double x_from_lon(float lon) {
    return lon * kDegreeToRadian * kEarthRadiusInMeters * std::cos(avg_lat * kDegreeToRadian);
}
//

double y_from_lat(double lat) {
    return lat * kDegreeToRadian* kEarthRadiusInMeters;

}

double lon_from_x(float x) {
    return x / (kDegreeToRadian * kEarthRadiusInMeters * std::cos(avg_lat * kDegreeToRadian));
}
//

double lat_from_y(float y) {
    return y / (kDegreeToRadian * kEarthRadiusInMeters);
}




std::vector<POIData> POIs; //declare vector to store info about points of interest

bool loadMap(std::string map_streets_database_filename) {

    map_path = map_streets_database_filename;

    bool load_successful = loadStreetsDatabaseBIN(map_streets_database_filename);
    if (!load_successful) return load_successful;

    std::cout << "loadMap: " << map_streets_database_filename << std::endl;

    std::string OSM_map_name = map_streets_database_filename;
    OSM_map_name.replace(map_streets_database_filename.length() - 11, 7, "osm");
    loadOSMDatabaseBIN(OSM_map_name);


    //Load data into the global variables: intersection_streetSegments, street_streetSegments, and streetSegments_intersection
    intersection_streetSegments.resize(getNumIntersections());
    street_streetSegments.resize(getNumStreets());
    streetSegments_intersection.resize(getNumStreetSegments());

    IntersectionIdx intersection;
    for (intersection = 0; intersection < getNumIntersections(); ++intersection) {
        for (int i = 0; i < getNumIntersectionStreetSegment(intersection); ++i) {
            int streetsegmentID = getIntersectionStreetSegment(intersection, i);

            IntersectionIdx interTo = getStreetSegmentInfo(streetsegmentID).to;
            IntersectionIdx interFrom = getStreetSegmentInfo(streetsegmentID).from;

            intersection_streetSegments[intersection].push_back(streetsegmentID);
            street_streetSegments[getStreetSegmentInfo(streetsegmentID).streetID].push_back(streetsegmentID);
            streetSegments_intersection[streetsegmentID].push_back(interTo);
            streetSegments_intersection[streetsegmentID].push_back(interFrom);
        }
    }

    std::vector<StreetSegmentIdx> path;
    
    
    
    
    //******TEST*******
    //path = findPathBetweenIntersections(13, 51601, 0.00000000000000000);
    //*********


    // Data structure (nested vector) for storing Intersection IDs corresponding to each Street ID 
    street_intersectionId.resize(getNumStreets());

    for (StreetIdx streetId = 0; streetId < getNumStreets(); ++streetId) {
        for (int strSegNum = 0; strSegNum < street_streetSegments[streetId].size(); ++strSegNum) {
            IntersectionIdx interFrom = getStreetSegmentInfo(street_streetSegments[streetId][strSegNum]).from;
            IntersectionIdx interTo = getStreetSegmentInfo(street_streetSegments[streetId][strSegNum]).to;
            street_intersectionId[streetId].push_back(interFrom);
            street_intersectionId[streetId].push_back(interTo);
        }
    }

    // To remove duplicates in the street_intersectionId data structure
    for (StreetIdx streetIds = 0; streetIds < getNumStreets(); ++streetIds) {
        //for removing duplicates
        std::unordered_set <IntersectionIdx> intersectionId;
        intersectionId.insert(street_intersectionId[streetIds].begin(), street_intersectionId[streetIds].end());
        while (!street_intersectionId[streetIds].empty()) {
            street_intersectionId[streetIds].pop_back();
        }

        for (const IntersectionIdx& id : intersectionId) {
            street_intersectionId[streetIds].push_back(id);
        }
    }





    //compute length of street segments
    streetSegmentsLength.resize(getNumStreetSegments());
    //
    for (StreetSegmentIdx strSegId = 0; strSegId < getNumStreetSegments(); strSegId++) {
        IntersectionIdx intersectionFrom = getStreetSegmentInfo(strSegId).from;
        IntersectionIdx intersectionTo = getStreetSegmentInfo(strSegId).to;

        double totalLength;
        std::pair<LatLon, LatLon> firstDistance, secondDistance, thirdDistance;
        int numberofcurvePoints = getStreetSegmentInfo(strSegId).numCurvePoints;
        std::pair<LatLon, LatLon> x;
        if (numberofcurvePoints == 0) {
            x.first = getIntersectionPosition(intersectionFrom);
            x.second = getIntersectionPosition(intersectionTo);

            totalLength = findDistanceBetweenTwoPoints(x);

            streetSegmentsLength[strSegId] = totalLength;
        } else { //if has 1 or more curve points
            firstDistance.first = getIntersectionPosition(intersectionFrom);
            firstDistance.second = getStreetSegmentCurvePoint(strSegId, 0);
            totalLength = findDistanceBetweenTwoPoints(firstDistance);

            for (int k = 0; k < numberofcurvePoints - 1; ++k) {

                secondDistance.first = getStreetSegmentCurvePoint(strSegId, k);
                secondDistance.second = getStreetSegmentCurvePoint(strSegId, k + 1);
                totalLength = totalLength + findDistanceBetweenTwoPoints(secondDistance);
            }

            thirdDistance.first = getStreetSegmentCurvePoint(strSegId, numberofcurvePoints - 1);
            thirdDistance.second = getIntersectionPosition(intersectionTo);
            totalLength = totalLength + findDistanceBetweenTwoPoints(thirdDistance);
            streetSegmentsLength[strSegId] = totalLength;
        }
    }
    //
    //
    ////    //compute travel times of street segments
    streetSegmentsTravelTime.resize(getNumStreetSegments());
    for (StreetSegmentIdx strSegId = 0; strSegId < getNumStreetSegments(); strSegId++) {
        double streetSegLength = findStreetSegmentLength(strSegId);
        double speedLimit = getStreetSegmentInfo(strSegId).speedLimit;
        streetSegmentsTravelTime[strSegId] = streetSegLength / speedLimit;
    }
    //
    //
    //    //compute lengths of streets
    //    
    streetLengths.resize(getNumStreets());
    StreetSegmentIdx strSegId;

    for (StreetIdx streetIden = 0; streetIden < getNumStreets(); streetIden++) {
        //StreetIdx strIdOfStrSeg;
        double streetLength = 0;
        for (int segNum = 0; segNum < street_streetSegments[streetIden].size(); segNum++) {
            strSegId = street_streetSegments[streetIden][segNum];
            streetLength = streetLength + streetSegmentsLength[strSegId];
        }

        streetLengths[streetIden] = streetLength / 2; //***need dividing by 2 probably because street_streetSegments has duplicate segment ids
    }


    //Multimap Data Structure for storing street names and street IDs
    streetNameAndID.resize(getNumStreets());
    for (StreetIdx streetide = 0; streetide < getNumStreets(); ++streetide) {
        std::string u = getStreetName(streetide);
        //
        //        //Source to remove white spaces " https://codereview.stackexchange.com/questions/71799/effective-way-to-remove-white-spaces-from-string   
        u.erase(std::remove(u.begin(), u.end(), ' '), u.end());
        //
        //        //Source to convert string into lowercase: https://stackoverflow.com/questions/3403844/tolower-function-for-c-strings
        std::transform(u.begin(), u.end(), u.begin(), ::tolower);
        //               
        streetNameAndID.push_back(std::pair<std::string, StreetIdx> (u, streetide));
    }
    std::sort(streetNameAndID.begin(), streetNameAndID.end(), [](const std::pair<std::string, StreetIdx> &left, const std::pair<std::string, StreetIdx> &right) {
        return left.second < right.second;
    });
    //    
    //    

    max1_lat = getIntersectionPosition(0).latitude();
    min1_lat = max1_lat;
    max1_lon = getIntersectionPosition(0).longitude();
    min1_lon = max1_lon;



    //for drawing intersections- Makes empty entry in this vector for each intersection
    intersections.resize(getNumIntersections());

    //load intersection data
    for (int id = 0; id < getNumIntersections(); ++id) {
        intersections[id].position = getIntersectionPosition(id);
        intersections[id].name = getIntersectionName(id);
        //Looping through max and min lat lon of each intersection
        max1_lat = std::max(max1_lat, intersections[id].position.latitude());
        min1_lat = std::min(min1_lat, intersections[id].position.latitude());
        max1_lon = std::max(max1_lon, intersections[id].position.longitude());
        min1_lon = std::min(min1_lon, intersections[id].position.longitude());
    }


    //Find avg latitude -used in conversion functions

    avg_lat = ((min1_lat + max1_lat) / 2);


    //  typeofRoad.resize(getNumStreets());

    int numWays = getNumberOfWays();
    for (int iway = 0; iway < numWays; iway++) { // Iterate through all the ways, from 0 to numWays - 1
        const OSMWay* theWay = getWayByIndex(iway); // Get a pointer to an object that gives info about one Way.
        OSMID osm_id = theWay->id(); // What is the OSMid for this way?
        // Now I have the OSMid of theWay, and I also have a pointer to the Way object.  
        umap[osm_id] = theWay;

    }


    for (StreetIdx streetid = 0; streetid < getNumStreets(); streetid++) {
        for (int sssid = 0; sssid < street_streetSegments[streetid].size(); sssid++) {
            IntersectionIdx intersectionFrom = getStreetSegmentInfo(street_streetSegments[streetid][sssid]).from;
            IntersectionIdx intersectionTo = getStreetSegmentInfo(street_streetSegments[streetid][sssid]).to;
            int curvepts = getStreetSegmentInfo(street_streetSegments[streetid][sssid]).numCurvePoints;

            LatLon y = getIntersectionPosition(intersectionFrom);
            max1_lat = std::max(max1_lat, y.latitude());
            min1_lat = std::min(min1_lat, y.latitude());
            max1_lon = std::max(max1_lon, y.longitude());
            min1_lon = std::min(min1_lon, y.longitude());

            //             avg_lat = (min_lat+max_lat / 2) ;
            //            
            LatLon w = getIntersectionPosition(intersectionTo);
            max1_lat = std::max(max1_lat, w.latitude());
            min1_lat = std::min(min1_lat, w.latitude());
            max1_lon = std::max(max1_lon, w.longitude());
            min1_lon = std::min(min1_lon, w.longitude());

            //             avg_lat = (min_lat+max_lat / 2) ;
            //           
            for (int k = 0; k < curvepts; k++) {
                LatLon x = getStreetSegmentCurvePoint((street_streetSegments[streetid][sssid]), k);
                max1_lat = std::max(max1_lat, x.latitude());
                min1_lat = std::min(min1_lat, x.latitude());
                max1_lon = std::max(max1_lon, x.longitude());
                min1_lon = std::min(min1_lon, x.longitude());
                //            
                //            avg_lat = (min_lat+max_lat / 2) ;
                //                
            }
            //           
        }
    }

    

    //load data for points of interest

    POIs.resize(getNumPointsOfInterest());
    //Getting all POI data by looping through all POI's 
    for (int id = 0; id < getNumPointsOfInterest(); id++) {
        LatLon latlonPos = getPOIPosition(id);
        ezgl::point2d xyPos(x_from_lon(latlonPos.longitude()), y_from_lat(latlonPos.latitude()));
        POIs[id].position = new ezgl::point2d(xyPos.x, xyPos.y);
        POIs[id].name = getPOIName(id);
        POIs[id].type = getPOIType(id);
    }

    for (int id = 0; id < getNumPointsOfInterest(); id++) POIs[id].closestPOIDistance = findClosestPOI_to_POIDistance(id);


   //load data for features

    features.resize(getNumFeatures());
    for (int id = 0; id < getNumFeatures(); id++) {
        int numPoints = getNumFeaturePoints(id);
         
        ezgl::point2d temppoint(0, 0);
        std::vector<ezgl::point2d> tempvector(numPoints, temppoint);
        features[id].positions = tempvector;

        features[id].positionsLatLon.resize(numPoints);
        
        
        //For loop for loading data for feature points
        for (int pNum = 0; pNum < numPoints; pNum++) {
            LatLon point_LatLon = getFeaturePoint(id, pNum);
            features[id].positionsLatLon[pNum] = getFeaturePoint(id, pNum); //load positions of feature points

            float x = x_from_lon(point_LatLon.longitude());
            float y = y_from_lat(point_LatLon.latitude());
            ezgl::point2d point(x, y);
            features[id].positions[pNum] = point;
        }

        features[id].name = getFeatureName(id);
        features[id].type = getFeatureType(id);
    }


    //  std::cout<<getNumIntersections()<<std::endl;   
    IntersectionIdx noOfIntersections;
    for (noOfIntersections = 0; noOfIntersections < getNumIntersections(); noOfIntersections++) {

        Node y;

        y.id = noOfIntersections;

        searchNode.push_back(y);


    }
    findAdjs.resize(getNumIntersections());
    int ssID;
    for (IntersectionIdx h = 0; h < getNumIntersections(); h++) {
        for (ssID = 0; ssID < findStreetSegmentsOfIntersection(h).size(); ssID++) {
            StreetSegmentIdx streetsegmentIDE = findStreetSegmentsOfIntersection(h)[ssID];
            if (getStreetSegmentInfo(streetsegmentIDE).oneWay == true && getStreetSegmentInfo(streetsegmentIDE).from == h) {


                findAdjs[h].push_back(streetsegmentIDE);
                // findss[h].push_back(findStreetSegmentsOfIntersection(h)[ssID]);
            }
            if (getStreetSegmentInfo(streetsegmentIDE).oneWay == false) {
                findAdjs[h].push_back(streetsegmentIDE);
                //  findss[h].push_back(findStreetSegmentsOfIntersection(h)[ssID]);
            }
        }
    }

    //path = findPathBetweenIntersections(6319, 90906, 0.00000000000000000);
    // path = findPathBetweenIntersections(135128,81484,27.036036110275663);
    
    
    
    
    
    
    
    isSegPartOfPath.resize(getNumStreetSegments());
    for (int i = 0; i < getNumStreetSegments(); i++) isSegPartOfPath[i] = false;
    
    
    
    return load_successful;

}


//Code for load Map 

double findClosestPOI_to_POIDistance(POIIdx thisPOI_ID) {

    bool firstMatchingPOI = true;
    double distance, minDistance;
    distance = 0.0 ; 
    minDistance = 0.0 ;
    double lat1, lat2, lon1, lon2;

    for (POIIdx POI_id = 0; POI_id < getNumPointsOfInterest(); POI_id++) {
        lat1 = POIs[POI_id].position->x;
        lat2 = POIs[thisPOI_ID].position->x;
        if (POI_id != thisPOI_ID && (lat1 - lat2) < 10) { //the latter conditions checks whether the two POIs are around the same latitude (horizontal position)  

            lon1 = POIs[POI_id].position->y;
            lon2 = POIs[thisPOI_ID].position->y;
            distance = sqrt(pow(lat1 - lat2, 2) + (pow(lon1 - lon2, 2)));

            if (firstMatchingPOI) {
                minDistance = distance; //assign an initial value to minDistance
                firstMatchingPOI = false; //the first matching POI has already been found
            }
            if (distance < minDistance) {
                minDistance = distance;
            }
        }
    }

    return minDistance;

}

void closeMap() {

    //Clean-up your map related data structures here

    closeStreetDatabase();
    closeOSMDatabase();
    //Clearing out data structures
    intersection_streetSegments.clear();
    street_streetSegments.clear();
    streetSegments_intersection.clear();
    street_intersectionId.clear();
    streetNameAndID.clear();
    intersections.clear();
    streetSegmentsLength.clear();
    streetSegmentsTravelTime.clear();
    streetLengths.clear();
    
    for (POIIdx Id = 0; Id < POIs.size(); Id++) {
        delete POIs[Id].position;
    }

    POIs.clear() ; 
    searchNode.clear();
    umap.clear();
    searchmap.clear();
    findss.clear();
    findAdjs.clear();
}


// Returns the distance between two (latitude,longitude) coordinates in meters
// Speed Requirement --> moderate

double findDistanceBetweenTwoPoints(std::pair<LatLon, LatLon> points) {

    //Declaring variables
    double latitude1, longitude1, latitude2, longitude2, latitudeAvg, x1, x2, distanceTwoPts;

    //Getting latitude and longitude from respective pairs
    longitude1 = kDegreeToRadian * points.first.longitude();
    longitude2 = kDegreeToRadian * points.second.longitude();
    latitude1 = kDegreeToRadian * points.first.latitude();
    latitude2 = kDegreeToRadian * points.second.latitude();

    //Compute the latitude average
    latitudeAvg = ((latitude1 + latitude2) / 2);

    //Finding x coordinate
    x1 = longitude1 * cos(latitudeAvg);
    x2 = longitude2 * cos(latitudeAvg);

    //Using Pythagoras theorem to find distance between 2 points
    distanceTwoPts = kEarthRadiusInMeters * sqrt((pow((latitude2 - latitude1), 2)) + (pow((x2 - x1), 2)));

    return distanceTwoPts;
}




// Returns the length of the given street segment in meters
// Speed Requirement --> moderate
//

double findStreetSegmentLength(StreetSegmentIdx street_segment_id) {
    //Returning precomputed street segment length 
    return (streetSegmentsLength[street_segment_id]);

}


// Returns the travel time to drive from one end of a street segment in
// to the other, in seconds, when driving at the speed limit
// Note: (time = distance/speed_limit)
// Speed Requirement --> high

double findStreetSegmentTravelTime(StreetSegmentIdx street_segment_id) {

    //Returning precomputed street segment travel time
    return (streetSegmentsTravelTime[street_segment_id]); //Return the travel time from the precomputation in load map

}


// Returns the nearest intersection to the given position
// Speed Requirement --> none

IntersectionIdx findClosestIntersection(LatLon my_position) {

    IntersectionIdx nearestInter = 0; //Protecting from garbage value
    double distance, minDistance;

    for (IntersectionIdx inter_id = 0; inter_id < getNumIntersections(); inter_id++) {
        std::pair<LatLon, LatLon> intersec_and_myPosition(getIntersectionPosition(inter_id), my_position);
        distance = findDistanceBetweenTwoPoints(intersec_and_myPosition);
        if (inter_id == 0) {
            minDistance = distance; //assign an initial value to minDistance
        }
        if (distance < minDistance) {
            minDistance = distance;
            nearestInter = inter_id; //store the ID of the closest intersection so far
        }
    }

    return nearestInter;
}




// Returns the street segments that connect to the given intersection
// Speed Requirement --> high

std::vector<StreetSegmentIdx> findStreetSegmentsOfIntersection(IntersectionIdx
intersection_id) {
    //Returning precomputed vector for street segments of intersections 
    return intersection_streetSegments[intersection_id];

}



// Returns the street names at the given intersection (includes duplicate
// street names in the returned vector)
// Speed Requirement --> high

std::vector<std::string> findStreetNamesOfIntersection(IntersectionIdx intersection_id) {
    //Retrieving street segment IDs from intersection_streetSegments data structure
    std::vector<StreetSegmentIdx> StreetSegIds = intersection_streetSegments[intersection_id];
    std::vector<std::string> streetNames;
    StreetIdx street_id;

    //Loop to get street names of the street that each street segment ID is a part of
    for (int i = 0; i < StreetSegIds.size(); i++) {
        street_id = getStreetSegmentInfo(StreetSegIds[i]).streetID;
        streetNames.push_back(getStreetName(street_id));
    }

    return (streetNames);
}


// Returns all intersections reachable by traveling down one street segment
// from the given intersection (hint: you can?t travel the wrong way on a
// 1-way street)
// the returned vector should NOT contain duplicate intersections
// Speed Requirement --> high

std::vector<IntersectionIdx> findAdjacentIntersections(IntersectionIdx intersection_id) {

    std::vector<IntersectionIdx> adjacentIntersec;

    StreetSegmentIdx id;
    //Using global variable to collect the street segments at intersection Id's
    std::vector<StreetSegmentIdx> intersecStreetSeg = intersection_streetSegments[intersection_id];
    int x = intersecStreetSeg.size();
    //At the given intersection iterating through all streetsegments
    if (x != 0) {
        for (id = 0; id <= (intersecStreetSeg.size()) - 1; id++) {

            //Get the street segment info for the id
            StreetSegmentInfo tempStreetSegInfo = getStreetSegmentInfo(intersecStreetSeg[id]);

            //Checking if the street segment is one way or not
            if (tempStreetSegInfo.oneWay == false) {
                if (intersection_id == tempStreetSegInfo.from) {
                    //If intersection is from, then add intersection.to
                    adjacentIntersec.push_back(tempStreetSegInfo.to);
                } else {
                    if (intersection_id == tempStreetSegInfo.to) {
                        //If intersection is to, then add intersection.from
                        adjacentIntersec.push_back(tempStreetSegInfo.from);
                    }
                }
            }

            if (tempStreetSegInfo.oneWay == true) {
                //if street segment ID is one-way, only add intersection.to since one way street segments go 'from' -> 'to'
                if (intersection_id == tempStreetSegInfo.from) {
                    (adjacentIntersec.push_back(tempStreetSegInfo.to));
                }
            }
        }
    } else {
        return adjacentIntersec;
    }

    //sort the elements from lowest to highest
    std::sort(adjacentIntersec.begin(), adjacentIntersec.end());

    std::vector<IntersectionIdx>::iterator it;

    //for removing duplicates

    it = std::unique(adjacentIntersec.begin(), adjacentIntersec.end()); //Checking how many unique elements exist so that there is no duplicate
    int numberofElements = std::distance(adjacentIntersec.begin(), it); //Counting how many elements in vector
    adjacentIntersec.resize(numberofElements);

    return (adjacentIntersec);

}





// Returns all intersections along the a given street
// Speed Requirement --> high

std::vector<IntersectionIdx> findIntersectionsOfStreet(StreetIdx street_id) {
    //Returns precomputed vector for findIntersectionsofStreet which is part of the data structure street_intersectionId
    return street_intersectionId[street_id];

}


// Return all intersection ids at which the two given streets intersect
// This function will typically return one intersection id for streets
// that intersect and a length 0 vector for streets that do not. For unusual
// curved streets it is possible to have more than one intersection at which
// two streets cross.
// Speed Requirement --> high

std::vector<IntersectionIdx> findIntersectionsOfTwoStreets(std::pair<StreetIdx, StreetIdx> street_ids) {
    std::vector<IntersectionIdx> street1_inters = findIntersectionsOfStreet(street_ids.first);
    std::vector<IntersectionIdx> street2_inters = findIntersectionsOfStreet(street_ids.second);

    sort(street1_inters.begin(), street1_inters.end());
    sort(street2_inters.begin(), street2_inters.end());

    std::vector<IntersectionIdx> commonInters(1000); //creates vector to contain common intersections (has 1000 empty slots)

    std::vector<IntersectionIdx>::iterator it, st;
    it = set_intersection(street1_inters.begin(), street1_inters.end(),
            street2_inters.begin(), street2_inters.end(), commonInters.begin()); //find common elements of the two vectors and store these into commonInters

    commonInters.resize(it - commonInters.begin()); //remove empty (unused) elements in commonInters vector

    return (commonInters);

}



// Returns all street ids corresponding to street names that start with the
// given prefix
// The function should be case-insensitive to the street prefix.
// The function should ignore spaces.
// For example, both "bloor " and "BloOrst" are prefixes to
// "Bloor Street East".
// If no street names match the given prefix, this routine returns an empty
// (length 0) vector.
// You can choose what to return if the street prefix passed in is an empty
// (length 0) string, but your program must not crash if street_prefix is a
// length 0 string.
// Speed Requirement --> high

std::vector<StreetIdx> findStreetIdsFromPartialStreetName(std::string street_prefix) {

    std::vector<StreetIdx> streetIdentity;
    ////
    ////    //Source to remove white spaces " https://codereview.stackexchange.com/questions/71799/effective-way-to-remove-white-spaces-from-string
    street_prefix.erase(std::remove(street_prefix.begin(), street_prefix.end(), ' '), street_prefix.end());
    ////
    ////    //Source to convert string into lowercase: https://stackoverflow.com/questions/3403844/tolower-function-for-c-strings
    std::transform(street_prefix.begin(), street_prefix.end(), street_prefix.begin(), ::tolower);
    ////
    auto it = streetNameAndID.begin();
    //for lower bounds
    ////    //Using lower bound range and comparing the string to figure out if its a prefix match
    while (it != streetNameAndID.end()) {
        if (it->first.compare(0, street_prefix.size(), street_prefix) == 0) {
            streetIdentity.push_back(it->second);
        }
        ++it;
    }
       //Checking for possibility of no street prefix match
    if (streetIdentity.size() == 0) {
        std::vector<StreetIdx> empty;
        return empty;
    }
    
    return streetIdentity;
}
  


// Returns the length of a given street in meters
// Speed Requirement --> high

double findStreetLength(StreetIdx street_id) {

    //Precomputed street lengths in loadmap
    return (streetLengths[street_id]);

}



// Return the smallest rectangle that contains all the intersections and
// curve points of the given street (i.e. the min,max lattitude
// and longitude bounds that can just contain all points of the street).
// Speed Requirement --> none

LatLonBounds findStreetBoundingBox(StreetIdx street_id) {

    LatLonBounds min_maxLatLon;
    LatLon pointLatLon;
    float min_lat = 360, max_lat = -360, min_lon = 360, max_lon = -360; //initialize min/max latlon values to be readily replaced by actual map latlon values

    //account for curve point positions
    for (StreetSegmentIdx StrSegId = 0; StrSegId < getNumStreetSegments(); StrSegId++) {
        if (getStreetSegmentInfo(StrSegId).streetID == street_id) {
            for (int pointNum = 0; pointNum < getStreetSegmentInfo(StrSegId).numCurvePoints; pointNum++) {
                pointLatLon = getStreetSegmentCurvePoint(StrSegId, pointNum); //get latlon of the curve point

                //only update min and max latlon with the point's latlon if it exceeded the previous min/max
                if (pointLatLon.latitude() < min_lat) min_lat = pointLatLon.latitude();
                if (pointLatLon.latitude() > max_lat) max_lat = pointLatLon.latitude();
                if (pointLatLon.longitude() < min_lon) min_lon = pointLatLon.longitude();
                if (pointLatLon.longitude() > max_lon) max_lon = pointLatLon.longitude();
            }
        }
    }

    //account for intersection positions
    std::vector<IntersectionIdx> streetInterIds = findIntersectionsOfStreet(street_id);
    for (int interNum = 0; interNum < streetInterIds.size(); interNum++) {
        pointLatLon = getIntersectionPosition(streetInterIds[interNum]);

        //only update min and max latlon with the point's latlon if it exceeded the previous min/max
        if (pointLatLon.latitude() < min_lat) min_lat = pointLatLon.latitude();
        if (pointLatLon.latitude() > max_lat) max_lat = pointLatLon.latitude();
        if (pointLatLon.longitude() < min_lon) min_lon = pointLatLon.longitude();
        if (pointLatLon.longitude() > max_lon) max_lon = pointLatLon.longitude();
    }

    //create LatLon variables to hold the min/max latlon values and assign them to min_maxLatLon
    LatLon minLatLon(min_lat, min_lon);
    min_maxLatLon.min = minLatLon;
    LatLon maxLatLon(max_lat, max_lon);
    min_maxLatLon.max = maxLatLon;

    return min_maxLatLon;
}


// Returns the nearest point of interest of the given name to the given position
// Speed Requirement --> none

POIIdx findClosestPOI(LatLon my_position, std::string POIname) {

    bool firstMatchingPOI = true;
    POIIdx nearestPOI = -1; //if returns -1 in the end, then it means nearest POI doesn't exist
    double distance, minDistance;

    for (POIIdx POI_id = 0; POI_id < getNumPointsOfInterest(); POI_id++) {
        if (getPOIName(POI_id) == POIname) {
            std::pair<LatLon, LatLon> POI_and_myPosition(getPOIPosition(POI_id), my_position);
            distance = findDistanceBetweenTwoPoints(POI_and_myPosition);
            if (firstMatchingPOI) {
                minDistance = distance; //assign an initial value to minDistance
                nearestPOI = POI_id;
                firstMatchingPOI = false; //the first matching POI has already been found
            }
            if (distance < minDistance) {
                minDistance = distance;
                nearestPOI = POI_id; //store the ID of the closest intersection so far
            }
        }
    }

    return (nearestPOI);
}




// Returns the area of the given closed feature in square meters
// Assume a non self-intersecting polygon (i.e. no holes)
// Return 0 if this feature is not a closed polygon.
// Speed Requirement --> moderate

double findFeatureArea(FeatureIdx feature_id) {

    double featureArea = 0;

    //check whether the polygon is closed
    LatLon firstPoint = getFeaturePoint(feature_id, 0);
    LatLon lastPoint = getFeaturePoint(feature_id, getNumFeaturePoints(feature_id) - 1);
    if ((firstPoint.latitude() != lastPoint.latitude()) || (firstPoint.longitude() != lastPoint.longitude())) return (featureArea); //returns 0 area if not closed polygon


    //if the feature is a closed polygon
    LatLon previousPoint, currentPoint;
    double lat1, lon1, lat2, lon2;
    double deltaX1, deltaX2, deltaY;
    double partialSectionArea;

    for (int pointNum = 0; pointNum + 1 < getNumFeaturePoints(feature_id); pointNum++) {
        previousPoint = getFeaturePoint(feature_id, pointNum);
        currentPoint = getFeaturePoint(feature_id, pointNum + 1);

        //convert degree values to radians
        lat1 = kDegreeToRadian * previousPoint.latitude();
        lon1 = kDegreeToRadian * previousPoint.longitude();
        lat2 = kDegreeToRadian * currentPoint.latitude();
        lon2 = kDegreeToRadian * currentPoint.longitude();

        deltaX1 = kEarthRadiusInMeters * (lon1 * cos(lat1));
        deltaX2 = kEarthRadiusInMeters * (lon2 * cos(lat2));
        deltaY = kEarthRadiusInMeters * (lat2 - lat1);
        partialSectionArea = (deltaX1 + deltaX2) / 2 * deltaY; //calculated the trapezoidal partial area formed by the two points and the longitude=0 vertical line
        featureArea = featureArea + partialSectionArea;
    }

    if (featureArea < 0) featureArea = -featureArea; //ensure the area is positive

    return (featureArea);
}

